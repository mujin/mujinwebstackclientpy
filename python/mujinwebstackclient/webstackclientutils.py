from functools import wraps
import copy

def GetMaximumQueryLimit(limit, maximumAllowedLimit=1000):
    """Makes sure the limit value used for querying is under maximumAllowedLimit

    Args:
        limit (int): The limit supplied by the user.
        maximumAllowedLimit (int, optional): The maximum allowed limit value in a single webstack call. Defaults to 1000.

    Returns:
        maximumAllowedLimit (int): The maximum allowed limit value in a single webstack call.
    """
    if limit > 0:
        return min(limit, maximumAllowedLimit)
    return maximumAllowedLimit

class QueryIterator:
    """Converts a large query to a iterator. The iterator will internally query webstack with a few small queries
    Examples:

      iterator = QueryIterator(client.GetScenes)
      iterator = QueryIterator(client.GetScenes, offset=10, limit=10)
      for scene in QueryIterator(client.GetScenes, offset=10, limit=10):
          do_something(scene)
    """

    _queryFunction = None # the actual webstack client query function (e.g. client.GetScenes)
    _queryArgs = None # positional arguments supplied to the query function (e.g. scenepk)
    _queryKwargs = None # keyword arguments supplied to the query function (e.g. offset=10, limit=20)
    _items = [] # internal buffer for items retrieved from webstack
    _shouldStop = False # boolean flag indicates whether need to query webstack again
    _initialLimit = None # the number of items user requests (0 means no limit)
    _count = 0 # the number of items already returned to user

    def __init__(self, queryFunction, *args, **kwargs):
        """Initialize all internal variables
        """
        # retrieve the actual query function instead of the wrapper function generated by UseLazyQuery decorator
        if hasattr(queryFunction, "inner"):
            args = (queryFunction.__self__,) + args
            queryFunction = queryFunction.inner

        # save the query function and all parameters
        self._queryFunction = queryFunction
        self._queryArgs = args
        self._queryKwargs = copy.deepcopy(kwargs)

        # initialize limit and offset
        self._queryKwargs.setdefault('offset', 0)
        self._queryKwargs.setdefault('limit', 0)
        self._initialLimit = self._queryKwargs['limit']

        # update the current limit
        self._queryKwargs['limit'] = GetMaximumQueryLimit(self._initialLimit)

    def __iter__(self):
        return self
    
    def __next__(self):
        """Retrieve the next item from iterator
           Required by Python3
        """
        return self.next()

    def next(self):
        """Retrieve the next item from iterator
           Required by Python2
        """
        # return an item from internal buffer if buffer is not empty
        if len(self._items) != 0:
            item = self._items[0]
            self._items = self._items[1:]
            self._count += 1
            return item

        # stop iteration if internal buffer is empty and no need to query webstack again
        if self._shouldStop:
            raise StopIteration

        # query webstack if buffer is empty
        self._items = self._queryFunction(*self._queryArgs, **self._queryKwargs)
        self._queryKwargs['offset'] += len(self._items)

        if len(self._items) < self._queryKwargs['limit']:
            # webstack does not have more items
            self._shouldStop = True
        if self._initialLimit != 0 and self._count + len(self._items) >= self._initialLimit:
            # all remaining items user requests are in internal buffer, no need to query webstack again
            self._shouldStop = True
            self._items = self._items[:self._initialLimit - self._count]

        return self.next()

class LazyQuery(list):
    """Wraps query response. Break a large query into smaller queries automatically to save memory.
    """
    _queryFunction = None # the actual webstack client query function (e.g. client.GetScenes)
    _queryArgs = None # positional arguments supplied to the query function (e.g. scenepk)
    _queryKwargs = None # keyword arguments supplied to the query function (e.g. offset=10, limit=20)
    _meta = None  # meta dict returned from webstack
    _items = None # internal buffer for items retrieved from webstack
    _totalCount = None # the number of available items in webstack
    _initialLimit = None # the original query limit specified by the user
    _currentLimit = None # the maximum limit determined to be used in the queries
    _initialOffset = None # the original query offset specified by the user
    _currentOffset = None # the offset for the first value inside buffer
    _fetchedAll = False # whether already has a complete list of query result

    def __init__(self, queryFunction, *args, **kwargs):
        """Initialize all internal variables
        """
        # save the query function and all parameters
        self._queryFunction = queryFunction
        self._queryArgs = args
        self._queryKwargs = copy.deepcopy(kwargs)

        # initialize limit and offset
        self._queryKwargs.setdefault('offset', 0)
        self._queryKwargs.setdefault('limit', 0)
        self._initialOffset = self._queryKwargs['offset']
        self._initialLimit = self._queryKwargs['limit']

        # get the meta only with a minimal webstack call
        self._currentOffset = self._initialOffset
        self._currentLimit = 1
        self._APICall()

        # update the current limit
        self._currentLimit = GetMaximumQueryLimit(self._initialLimit)

    def __iter__(self):
        if self._fetchedAll:
            return super(LazyQuery, self).__iter__()
        # return an iterator with the original offset and limit values
        self._queryKwargs['offset'] = self._initialOffset
        self._queryKwargs['limit'] = self._initialLimit
        return QueryIterator(self._queryFunction, *self._queryArgs, **self._queryKwargs)
    
    def _APICall(self):
        """Make one webstack query
        """
        # fetch data starting from the requested offset and limit
        self._queryKwargs['offset'] = self._currentOffset
        self._queryKwargs['limit'] = self._currentLimit
        # get the latest results
        self._items = self._queryFunction(*self._queryArgs, **self._queryKwargs)
        self._meta = self._items._meta
        self._totalCount = self._meta['total_count']

    @property
    def totalCount(self):
        # return the latest total count
        return self._totalCount

    @property
    def limit(self):
        # return the initial limit since the limit from meta keeps changing
        return self._initialLimit

    @property
    def offset(self):
        # return the initial limit since the offset from meta keeps changing
        return self._initialOffset
    
    def FetchAll(self):
        """Fetch the complete query result from webstack
        """
        if self._fetchedAll:
            return
        self._queryKwargs['offset'] = self._initialOffset
        self._queryKwargs['limit'] = self._initialLimit
        items = list(QueryIterator(self._queryFunction, *self._queryArgs, **self._queryKwargs))
        super(LazyQuery, self).__init__(items)
        self._fetchedAll = True

    def __len__(self):
        if self._fetchedAll:
            return super(LazyQuery, self).__len__()
        # if there is no limit or the limit is larger than the number of items webstack actual has,
        # the length is the total number of items minus the offset.
        # e.g. totalCount = 100, offset = 5, limit = 0 or 99999 => length = 100 - 5 = 95 
        if self._initialLimit == 0 or self._initialOffset + self._initialLimit >= self.totalCount:
            # if offset is larger than the number of items webstack actual has, 
            # length is 0 and the query result is an empty list.
            # e.g. totalCount = 100, offset = 9999999 => length = 0
            return max(0, self.totalCount - self._initialOffset)
        # otherwise, the length of the items is the limit,
        # e.g. totalCount = 100, offset = 5, limit = 10 => length = 10
        return self._initialLimit

    def __getitem__(self, index):
        if self._fetchedAll:
            return super(LazyQuery, self).__getitem__(index)
        
        # index could be a slice object
        # python2 e.g. scenes.__getitem__(slice(1, None))
        # python3 e.g. scenes[1:]
        if type(index) is slice:
            self.FetchAll()
            return super(LazyQuery, self).__getitem__(index)
        
        # convert negative index to positive index
        if index < 0:
            index = len(self) + index

        if index < 0 or index >= len(self):
            raise IndexError('query result index out of range')

        offset = self._initialOffset + index
        if offset >= self._currentOffset and offset < self._currentOffset + len(self._items):
            # buffer hit
            return self._items[offset - self._currentOffset]
        
        # drop buffer and query webstack again
        self._currentOffset = offset
        # don't update the limit
        self._APICall()
        return self.__getitem__(index)

    def __repr__(self):
        # if we already fetched all
        if self._fetchedAll:
            return super(LazyQuery, self).__repr__()
        # if we fetched every item we could fetch
        if len(self._items) == self._totalCount - self._initialOffset:
            return self._items.__repr__()
        # if we are holding partial data
        return '[..., ' + self._items.__repr__()[1:-1] + ', ...]'

    # When invoke the following functions, 
    # LazyQuery object will fetch the complete list of query result from webstack,
    # and it behaves identical to a standard list from this point forward.

    def __setitem__(self, index, item):
        self.FetchAll()
        return super(LazyQuery, self).__setitem__(index, item)

    def append(self, item):
        self.FetchAll()
        return super(LazyQuery, self).append(item)

    def extend(self, items):
        self.FetchAll()
        return super(LazyQuery, self).extend(items)

    def insert(self, index, item):
        self.FetchAll()
        return super(LazyQuery, self).insert(index, item)

    def index(self, *arg):
        self.FetchAll()
        return super(LazyQuery, self).index(*arg)

    def pop(self):
        self.FetchAll()
        return super(LazyQuery, self).pop()

    def count(self, item):
        self.FetchAll()
        return super(LazyQuery, self).count(item)

    def remove(self, item):
        self.FetchAll()
        return super(LazyQuery, self).remove(item)

    def reverse(self):
        self.FetchAll()
        return super(LazyQuery, self).reverse()

    def sort(self, reverse=False, key=None):
        self.FetchAll()
        return super(LazyQuery, self).sort(reverse=reverse, key=key)

    def __iadd__(self, items):
        self.FetchAll()
        return super(LazyQuery, self).__iadd__(items)

    def __add__(self, items):
        self.FetchAll()
        return super(LazyQuery, self).__add__(items)

    def __rmul__(self, value):
        self.FetchAll()
        return super(LazyQuery, self).__rmul__(value)

    def __mul__(self, value):
        self.FetchAll()
        return super(LazyQuery, self).__mul__(value)

    def __imul__(self, value):
        self.FetchAll()
        return super(LazyQuery, self).__imul__(value)

    def __reversed__(self):
        self.FetchAll()
        return super(LazyQuery, self).__reversed__()

    def __contains__(self, item):
        self.FetchAll()
        return super(LazyQuery, self).__contains__(item)

    def __delitem__(self, index):
        self.FetchAll()
        return super(LazyQuery, self).__delitem__(index)
    
    def __getslice__(self, start, end):
        self.FetchAll()
        return super(LazyQuery, self).__getslice__(start, end)
    
    def __setslice__(self, start, end, value):
        self.FetchAll()
        return super(LazyQuery, self).__setslice__(start, end, value)
    
    def __delslice__(self, start, end):
        self.FetchAll()
        return super(LazyQuery, self).__delslice__(start, end)
    
    def __eq__(self, other):
        self.FetchAll()
        if isinstance(other, LazyQuery):
            other.FetchAll()
        return super(LazyQuery, self).__eq__(other)
    
    def __ne__(self, other):
        self.FetchAll()
        if isinstance(other, LazyQuery):
            other.FetchAll()
        return super(LazyQuery, self).__ne__(other)
    
    def __lt__(self, other):
        self.FetchAll()
        if isinstance(other, LazyQuery):
            other.FetchAll()
        return super(LazyQuery, self).__lt__(other)
    
    def __gt__(self, other):
        self.FetchAll()
        if isinstance(other, LazyQuery):
            other.FetchAll()
        return super(LazyQuery, self).__gt__(other)
    
    def __le__(self, other):
        self.FetchAll()
        if isinstance(other, LazyQuery):
            other.FetchAll()
        return super(LazyQuery, self).__le__(other)
    
    def __ge__(self, other):
        self.FetchAll()
        if isinstance(other, LazyQuery):
            other.FetchAll()
        return super(LazyQuery, self).__ge__(other)

def UseLazyQuery(queryFunction):
    """This decorator break a large query into a few small queries with the help of LazyQuery class to prevent webstack from consuming too much memory.
    """
    @wraps(queryFunction)
    def wrapper(self, *args, **kwargs):
        queryResult = LazyQuery(queryFunction, *((self,) + args), **kwargs)
        return queryResult
    
    wrapper.inner = queryFunction
    return wrapper    
